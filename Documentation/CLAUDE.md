# Arcane Coop - Claude.md

This file provides guidance to Claude Code when working with the Arcane Coop escape room project.

## Project Overview

**Arcane Coop** is a sophisticated cooperative puzzle game platform built with ASP.NET Core Blazor Server (.NET 9.0). Set in the Arcane universe, it features 7 distinct puzzle systems where two players representing Zaun and Piltover must work together to solve challenges through real-time communication and collaboration.

## Development Commands

### Build Commands
```bash
dotnet build
dotnet clean
dotnet restore
```

### Running the Application
**Note: The user prefers to run the application manually.**
The application runs on:
- HTTP: http://localhost:5055
- HTTPS: https://localhost:7104

When the user runs `dotnet run`, the application will be available at the above URLs.

### Publishing
```bash
dotnet publish -c Release
```

## Architecture

### Project Structure
- **Program.cs**: Main entry point with minimal API setup
- **Components/**: Contains all Razor components
  - **App.razor**: Root component with HTML document structure
  - **Routes.razor**: Router configuration
  - **_Imports.razor**: Global using statements
  - **Layout/MainLayout.razor**: Base layout component
  - **Pages/**: Page components
    - **LandingPage.razor**: Main game selection page with extensive CSS styling
    - **Error.razor**: Standard error page

### Technology Stack
- **Framework**: ASP.NET Core 9.0 with Blazor Server
- **Rendering**: Interactive Server Components
- **Styling**: Component-scoped CSS with extensive custom styling
- **Fonts**: Custom "Arcane Nine" font and Google Fonts (Orbitron, Cinzel, Rajdhani)

### Service Layer (2025)
- **Act1StoryEngine**: Server-side story engine for Act 1. Provides scene content, player view construction, and progression logic
  - File: `Services/Act1StoryEngine.cs`
  - Interface: `IAct1StoryEngine`
  - Registered in `Program.cs` via DI: `AddSingleton<IAct1StoryEngine, Act1StoryEngine>()`

### Core Features
- **7 Cooperative Puzzle Systems** - Each with unique mechanics and educational focus
- **Real-time Multiplayer** - SignalR-powered synchronization between players
- **Dual-theme Arcane Design** - Zaun (teal/underground) vs Piltover (gold/clean) aesthetics
- **Role-based Gameplay** - Players have different views and responsibilities
- **Educational Focus** - Designed for ESL students and skill development

### Development Patterns
- Uses **minimal APIs** for simple setup
- **Component-scoped CSS** with extensive styling (1000+ lines in LandingPage)
- **Enum-based** city selection (City.Zaun, City.Piltover)
- **Async/await** patterns for component interactions
- **Cascading parameters** for context sharing
- **CSS @ symbols must be escaped** in Razor components: use `@@keyframes`, `@@media`, `@@import`, `@@font-face`
- **Server-authoritative story flow**: Hubs remain thin; story content and branching live in services (e.g., `Act1StoryEngine`)

### Visual Novel Multiplayer Editor Notes (2025)

For reliable Visual Novel behavior in multiplayer (Act 1) and in the visual editor:

- Use `CancellationTokenSource` and a `CancelTypewriter()` helper to cancel any in-flight typewriter animation
- Reset local text state (`displayedText`, `currentTextIndex`) and force a render before starting a new animation to avoid first-character carry-over
- On Skip, cancel the animation and set the full line once; also notify the server (see `Act1TypingCompleted`) so both clients' buttons flip from Skip → Continue
- Add a `Act1TypingCompleted(roomId)` hub method that marks `IsTextAnimating=false` and `GameState.IsTextFullyDisplayed=true`, then broadcasts the updated `Act1PlayerView`
- After `Act1SceneTransition`, add a short client fallback (e.g., 4s) to navigate to the next game if the redirect message is missed

### Static Assets
- Located in **wwwroot/**
- Character images: Vi.jpeg, Cait.jpeg, Jayce.jpeg, Viktor.jpeg
- Custom font: Arcane Nine.otf
- Component-specific CSS files generated by build process

### Configuration
- Standard ASP.NET Core configuration in **appsettings.json**
- Development/Production environment support
- HTTPS redirection and HSTS enabled for production

## Legacy Systems

### Tic-Tac-Toe Demo (/test-signalr)
Early proof-of-concept for SignalR multiplayer functionality. Fully functional with real-time synchronization, but not part of the main escape room experience.



## SignalR Best Practices Summary

Key guidelines for robust multiplayer implementation:

- **Type Safety**: Always use strongly-typed data models for SignalR messages
- **State Sync**: Update both game state and player views after changes
- **Connection Management**: Handle joins, leaves, and disconnections gracefully
- **Server Validation**: Never trust client input - validate all actions server-side
- **Error Handling**: Comprehensive error messages and proper exception handling
- **Performance**: Use concurrent collections and batch updates when possible

See individual puzzle documentation for implementation examples.


## Puzzle Systems Overview

The project features 7 distinct cooperative puzzle systems, each designed for 2 players with asymmetric information and roles:

### 1. CodeCracker (/code-cracker)
**Purpose**: Vocabulary building and communication
**Players**: Piltover (sees distorted words) + Zaunite (gets clues)
**Mechanics**: Word decryption with hints and scoring
**Education**: ESL vocabulary, German translations
**Documentation**: [CodeCracker.md](./CodeCracker.md)

### 2. SignalDecoder (/signal-decoder) 
**Purpose**: Listening comprehension
**Players**: Piltover (sees incomplete text) + Zaunite (hears audio)
**Mechanics**: Audio-text coordination with emergency scenarios
**Education**: Listening skills, emergency vocabulary
**Documentation**: [SignalDecoder.md](./SignalDecoder.md)

### 3. NavigationMaze (/navigation-maze)
**Purpose**: Spatial reasoning and direction following
**Players**: Piltover (map navigator) + Zaunite (first-person explorer)
**Mechanics**: Pathfinding through dangerous Zaun locations
**Education**: Prepositions, spatial vocabulary
**Documentation**: [NavigationMaze.md](./NavigationMaze.md)

### 4. PictureExplanation (/picture-explanation)
**Purpose**: Visual communication over voice chat
**Players**: Piltover (image describer) + Zaunite (choice selector)
**Mechanics**: Describe → Hide → Choose from 4 options
**Education**: Descriptive language, active listening
**Documentation**: [PictureExplanation.md](./PictureExplanation.md)

**Story Integration Features:**
- **Story Mode Entry**: Accepts `story=true` parameter to bypass lobby setup
- **Role Preservation**: Uses `JoinPictureExplanationGameWithRole()` to maintain Piltover/Zaun assignments from visual novel
- **Completion Transition**: "Continue Story" button (instead of "Play Again") when completing puzzle in story mode
- **Scene Targeting**: Redirects both players to next visual novel scene with `sceneIndex` parameter

### 5. RuneProtocol (/rune-protocol)
**Purpose**: Logic puzzles and conditional reasoning
**Players**: Piltover (R1-R4) + Zaunite (R5-R8)
**Mechanics**: Satisfy complex rule conditions through coordination
**Education**: Logic, Boolean algebra, systems thinking
**Documentation**: [RuneProtocol.md](./RuneProtocol.md)

### 6. AlchemyLab (/alchemy-lab)
**Purpose**: Process following and drag-and-drop interaction
**Players**: Piltover (recipe reader) + Zaunite (hands-on brewer)
**Mechanics**: Multi-step ingredient processing and combination
**Education**: Following instructions, sequential thinking
**Documentation**: [AlchemyLab.md](./AlchemyLab.md)

### 7. VisualNovel (/visual-novel)
**Purpose**: Narrative delivery and story immersion
**Players**: Single or dual player story experience
**Mechanics**: Text animation, character expressions, thematic presentation
**Education**: Reading comprehension, cultural context
**Documentation**: [VisualNovel.md](./VisualNovel.md)

## Technical Architecture

### Multiplayer Infrastructure
- **SignalR Hubs**: Real-time communication via `GameHub.cs` (thin coordinator)
- **Room-based Games**: Players join rooms using shared codes
- **Role Assignment**: First player = Piltover, Second = Zaunite
  - Story override: per-player URL `role` can request Piltover/Zaun; server resolves conflicts and ensures distinct roles
- **State Synchronization**: Server-side validation with client updates
- **Act 1 Story Engine**: `IAct1StoryEngine` owns scene content and branching
  - Hub methods (`JoinAct1Game`, `SkipAct1Text`, `ContinueAct1`, `Act1TypingCompleted`, `MakeAct1Choice`, `RestartAct1`) delegate to the engine and broadcast views
- **Connection Management**: Graceful handling of disconnections

### Data Models
- **Game-specific Models**: Each puzzle has dedicated model classes
- **Player Views**: Role-specific data structures for asymmetric gameplay
- **Game States**: Comprehensive state tracking for all game phases
  - Act 1 uses `Act1MultiplayerGame`, `Act1Player`, `Act1PlayerView`, `VisualNovelScene`, `DialogueLine`, `DialogueChoice`

### Component Architecture
- **Page Components**: Each puzzle is a standalone Blazor page
- **Shared Services**: Common functionality via dependency injection
- **CSS Theming**: Consistent Piltover/Zaun visual identity
- **Responsive Design**: Desktop-first with mobile support

## Story-Puzzle Transition System

The project implements a sophisticated transition system that allows seamless navigation between visual novel scenes and puzzle gameplay while preserving player roles, state, and multiplayer synchronization.

### Architecture Overview

**Flow Control Pattern:**
```
Visual Novel Scene → Puzzle → Next Visual Novel Scene
```

**Key Components:**
- **StoryProgression**: Ordered list defining the sequence (scenes and puzzle transitions)
- **Scene Index Management**: Tracks current position in the story progression
- **Role Preservation**: Maintains player roles (Piltover/Zaun) across transitions
- **Parameter Passing**: URL-based state transfer between different game types

### Story Progression Configuration

The story flow is controlled by the `StoryProgression` array in `Act1MultiplayerGame`:

```csharp
public List<string> StoryProgression { get; set; } = new() 
{ 
    "emergency_briefing",           // Scene 1 & 2 - Visual Novel
    "picture_explanation_transition", // Puzzle - Picture Explanation
    "database_revelation"           // Scene 3 - Visual Novel
};
```

### From Scene to Puzzle Transitions

**Step 1: Scene Completion Detection**
- Visual novel reaches end of dialogue
- `_act1StoryEngine.ProgressToNextScene()` is called
- System detects `*_transition` phase in StoryProgression

**Step 2: Transition Initialization**
```csharp
case "picture_explanation_transition":
    game.Status = Act1GameStatus.SceneTransition;
    game.ShowTransition = true;
    game.NextGameName = "Visual Intelligence Analysis";
```

**Step 3: URL Construction with State Preservation**
```csharp
var parameters = $"role={p.PlayerRole}&avatar={p.PlayerAvatar}&name={Uri.EscapeDataString(p.PlayerName)}&squad={Uri.EscapeDataString(p.OriginalSquadName)}&story=true";
var url = $"/picture-explanation?{parameters}";
```

**Critical Parameters:**
- `role`: Preserves Piltover/Zaun assignment
- `avatar`: Maintains visual identity
- `name`: Player identification
- `squad`: Room/session identifier
- `story=true`: Enables story mode in puzzle

**Step 4: Synchronized Player Redirection**
```csharp
foreach (var p in game.Players)
{
    result.RedirectUrlsByPlayerId[p.PlayerId] = url;
}
```

### From Puzzle to Scene Transitions

**Step 1: Puzzle Completion**
- Puzzle game reaches completion state
- Story-mode conditional UI appears

**Step 2: Continue Story Button**
```razor
@if (isFromStory)
{
    <button class="arcane-btn arcane-btn-success" @onclick="ContinueStory">
        ➡️ Continue Story
    </button>
}
```

**Step 3: Hub Method for Story Continuation**
```csharp
public async Task ContinueStoryToScene3(string roomId)
{
    // Get puzzle players
    var connectedPlayers = game.GetConnectedPlayers();
    
    // Build Act1 URLs with scene targeting
    var parameters = $"role={roleName}&avatar=1&name={playerName}&roomId={roomId}&squad={roomId}&sceneIndex=2";
    var url = $"/act1-multiplayer?{parameters}";
}
```

**Critical Parameters for Scene Targeting:**
- `roomId`: Primary identifier for Act1 game room
- `squad`: Secondary identifier (same as roomId for continuity)  
- `sceneIndex`: Specifies which scene to start at (bypasses early scenes)

**Step 4: Scene Index Handling**
```csharp
public async Task JoinAct1GameAtScene(string roomId, string playerName, string originalSquadName, string role, string avatar, int? startAtSceneIndex)
{
    if (startAtSceneIndex.HasValue && startAtSceneIndex.Value >= 0)
    {
        game.CurrentSceneIndex = startAtSceneIndex.Value;
        var currentPhase = game.StoryProgression[game.CurrentSceneIndex];
        
        if (currentPhase == "database_revelation")
        {
            game.CurrentScene = _act1StoryEngine.CreateDatabaseRevelationScene(originalSquadName, game);
        }
    }
}
```

### Implementation Requirements

#### For Scene-to-Puzzle Transitions

**1. StoryEngine Updates (Services/Act1StoryEngine.cs)**
```csharp
case "puzzle_name_transition":
    game.Status = Act1GameStatus.SceneTransition;
    game.ShowTransition = true;
    game.NextGameName = "Puzzle Display Name";
    
    result.TransitionStarted = true;
    result.NextGameName = game.NextGameName;
    
    var puzzleUrls = new Dictionary<string, string>();
    foreach (var p in game.Players)
    {
        var parameters = $"role={p.PlayerRole}&avatar={p.PlayerAvatar}&name={Uri.EscapeDataString(p.PlayerName)}&squad={Uri.EscapeDataString(p.OriginalSquadName)}&story=true";
        puzzleUrls[p.PlayerId] = $"/puzzle-url?{parameters}";
    }
    result.RedirectUrlsByPlayerId = puzzleUrls;
```

**2. Visual Novel UI (Act1Multiplayer.razor)**
- Transition screen with loading animation
- Fallback redirect mechanism (4-second timer)
- `hasNavigatedToNextGame` flag to prevent duplicate redirects

#### For Puzzle-to-Scene Transitions

**1. Puzzle Completion UI**
```razor
@if (isFromStory && gameState.IsCompleted)
{
    <button class="arcane-btn arcane-btn-success" @onclick="ContinueStory">
        ➡️ Continue Story
    </button>
}
```

**2. SignalR Hub Method (GameHub.cs)**
```csharp
public async Task ContinuePuzzleToNextScene(string roomId, int targetSceneIndex)
{
    var puzzleGame = GetPuzzleGame(roomId);
    var players = puzzleGame.GetConnectedPlayers();
    
    foreach (var connectionId in players)
    {
        var playerData = GetPlayerData(connectionId);
        var url = $"/act1-multiplayer?role={playerData.Role}&roomId={roomId}&squad={roomId}&sceneIndex={targetSceneIndex}";
        await Clients.Client(connectionId).SendAsync("RedirectToNextScene", url);
    }
}
```

**3. Scene Index Support (Act1Multiplayer.razor)**
```csharp
// URL Parsing
if (int.TryParse(query["sceneIndex"], out int targetSceneIndex))
{
    startAtSceneIndex = targetSceneIndex;
}

// Hub Method Selection
if (startAtSceneIndex.HasValue)
{
    await hubConnection.SendAsync("JoinAct1GameAtScene", currentRoomId, playerName, originalSquadName, playerRole, playerAvatar, startAtSceneIndex.Value);
}
```

### Critical Implementation Details

#### Parameter Name Consistency
**❌ Common Error:**
```
Puzzle redirects to: /act1-multiplayer?squad=roomName&sceneIndex=2
Act1Multiplayer expects: roomId parameter
Result: Empty currentRoomId → Squad Synchronization failure
```

**✅ Correct Implementation:**
```
Puzzle redirects to: /act1-multiplayer?roomId=roomName&squad=roomName&sceneIndex=2
Act1Multiplayer parses: currentRoomId = roomName ✓
```

#### Role Preservation Strategy
- **Never rely on automatic assignment** (first=Piltover, second=Zaun) 
- **Always pass explicit `role` parameter** in transition URLs
- **Handle role conflicts** in puzzle join methods (second player gets remaining role)
- **Maintain role consistency** throughout entire session

#### State Synchronization Points
1. **Scene Completion**: Check if all players reached the end
2. **Transition Start**: Ensure both players get redirect simultaneously  
3. **Puzzle Join**: Wait for both players before starting puzzle
4. **Puzzle Completion**: Only show continue button when both players finished
5. **Scene Resume**: Both players must join Act1 game before story continues

#### Error Handling Requirements
- **Connection Failures**: Graceful degradation with fallback redirects
- **Parameter Errors**: Clear error messages for debugging
- **Room Mismatches**: Prevent players from joining wrong sessions
- **State Desync**: Automatic recovery mechanisms

### Testing and Debugging

#### Debug Logging Strategy
```csharp
Console.WriteLine($"[GameHub] Redirecting player {connectionId} to: {url}");
Console.WriteLine($"[Act1Multiplayer] Parsed URL params - RoomId: '{currentRoomId}', SceneIndex: {startAtSceneIndex}");
Console.WriteLine($"[Act1Multiplayer] Joining Act1 game at scene {startAtSceneIndex.Value}");
```

#### Common Issues and Solutions

**Issue: "Squad Synchronization" Loop**
- **Cause**: Missing or incorrect `roomId` parameter
- **Solution**: Verify URL construction includes both `roomId` and `squad` parameters

**Issue: Players Start at Wrong Scene**  
- **Cause**: Scene index not handled for second player
- **Solution**: Update join logic to handle `startAtSceneIndex` for all players

**Issue: Role Assignments Switch**
- **Cause**: Relying on join order instead of explicit role parameter
- **Solution**: Always use `JoinPuzzleGameWithRole` methods with explicit role requests

**Issue: Players Get Stuck in Transition**
- **Cause**: Redirect URLs not sent or navigation blocked
- **Solution**: Implement fallback redirect timer and verify SignalR connection state

This comprehensive transition system enables seamless story-driven gameplay where puzzles feel integrated into the narrative rather than separate mini-games.

## Development Guidelines

### Adding New Puzzles
1. Create page component in Components/Pages/
2. Add models in Models/ directory
3. Implement SignalR methods in GameHub.cs
4. Create comprehensive documentation in Documentation/
5. Update this CLAUDE.md with basic overview

### Code Standards
- **SignalR Type Safety**: Always use strongly-typed data models
- **Error Handling**: Graceful degradation for network issues
- **State Management**: Separate client/server state concerns
- **Animation**: Hardware-accelerated CSS for 60fps performance
- **Accessibility**: ARIA labels and keyboard navigation

### Educational Focus
- **German ESL Students**: Primary target audience
- **Collaborative Learning**: Peer-to-peer skill development
- **Progressive Difficulty**: Scaffolded complexity increases
- **Multiple Modalities**: Visual, auditory, kinesthetic learning styles

## File Organization

### Core Files
- **Program.cs**: Application entry point and service configuration
- **GameHub.cs**: SignalR hub with all multiplayer functionality
- **appsettings.json**: Configuration for development and production

### Component Structure
- **Pages/**: All puzzle components and main game pages
- **Models/**: Data models for each puzzle system
- **Services/**: Shared services (VisualNovelService, etc.)
- `Act1StoryEngine` provides Act 1 narrative; `VisualNovelService` provides generic VN scenes/utilities
- **wwwroot/**: Static assets (images, audio, fonts, styles)

### Documentation Structure
- **CLAUDE.md**: This overview and development guidance
- **[PuzzleName].md**: Detailed documentation for each puzzle system
- **Specialized docs**: Technical deep-dives for complex systems

## GameHub.cs - Central SignalR Hub Documentation

The `GameHub.cs` file serves as the central multiplayer coordination hub for all puzzle systems in the Arcane Coop project. This SignalR hub manages real-time communication, game state synchronization, and player coordination across all puzzle types.

### File Structure Overview

**Core Infrastructure (Lines 1-64)**
- Static game dictionaries for each puzzle type
- Room and player management
- Basic SignalR connection handling

**Game-Specific Sections (high level):**
- **Tic-Tac-Toe** (Lines 65-111): Legacy demo system with basic turn-based gameplay
- **CodeCracker** (Lines 112-190): Vocabulary puzzle with word guessing and hint system
- **SignalDecoder** (Lines 191-286): Audio-based emergency transmission decoding
- **NavigationMaze** (Lines 287-381): Spatial navigation with route planning
- **AlchemyLab** (Lines 382-524): Drag-and-drop ingredient processing and brewing
- **RuneProtocol** (Lines 525-670): Complex logic puzzle with conditional rule systems
- **PictureExplanation** (Lines 671-825): Voice chat visual communication challenges
- **Word-Forge** (Lines 826-934): Advanced word formation and affix combinations
 - **Act 1 Story (thin)**: Delegates to `IAct1StoryEngine` for content and branching; hub focuses on joins, skips, continue, typing completion, choices, restarts, and broadcasting

**Connection Management (Lines 935-end)**: Player disconnection handling and cleanup

### Static Game Storage Architecture

```csharp
// Each puzzle type maintains its own concurrent dictionary (Lines 10-18)
private static readonly ConcurrentDictionary<string, TicTacToeGame> _games = new();
private static readonly ConcurrentDictionary<string, CodeCrackerGame> _codeCrackerGames = new();
private static readonly ConcurrentDictionary<string, SimpleSignalDecoderGame> _signalDecoderGames = new();
private static readonly ConcurrentDictionary<string, NavigationMazeGame> _navigationMazeGames = new();
private static readonly ConcurrentDictionary<string, AlchemyGame> _alchemyGames = new();
private static readonly ConcurrentDictionary<string, RuneProtocolGame> _runeProtocolGames = new();
private static readonly ConcurrentDictionary<string, PictureExplanationGame> _pictureExplanationGames = new();
private static readonly ConcurrentDictionary<string, WordForgeGame> _wordForgeGames = new();
private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, string>> _roomPlayers = new();
```

### Common Method Patterns

Each puzzle section follows consistent patterns:

#### 1. **Join Game Methods** (Lines 113, 192, 288, 383, 526, 672, 827)
- Pattern: `JoinXXXGame(string roomId, string playerName)`
- Adds player to SignalR group
- Creates or retrieves game instance
- Assigns player role (typically Piltover vs Zaunite)
- Sends initial game state and player-specific view

#### 2. **Game Action Methods** (Varies by puzzle)
- **CodeCracker**: `SubmitCodeCrackerGuess()` (Line 132), `RequestCodeCrackerHint()` (Line 163)
- **SignalDecoder**: `SubmitSignalDecoding()` (Line 232)
- **NavigationMaze**: `MakeNavigationChoice()` (Line 315)
- **AlchemyLab**: `ProcessIngredient()` (Line 409), `AddToCauldron()` (Line 440), `SubmitPotion()` (Line 473)
- **RuneProtocol**: `ToggleRune()` (Line 557), `ToggleRuneProtocolValidationHints()` (Line 602)
- **PictureExplanation**: `SubmitPictureChoice()` (Line 736), `NextPictureRound()` (Line 780)
- **Word-Forge**: `ForgeWordCombination()` (Line 890)

#### 3. **Restart/Reset Methods** (Lines 176, 243, 353, 510, 637, 810, 919)
- Pattern: `RestartXXXGame(string roomId)`
- Resets game state to initial conditions
- Broadcasts updated state to all players

### Advanced Features by Puzzle

#### **CodeCracker (Lines 112-190)**
- **Hint System**: Players can request hints with usage tracking
- **Scoring System**: Points based on speed and accuracy
- **Progressive Difficulty**: Word complexity increases through rounds
- **Animation Coordination**: 2.5-second delays for success animations

#### **SignalDecoder (Lines 191-286)**
- **Emergency Scenarios**: Multiple crisis types (medical, fire, police, disasters)
- **Signal Degradation**: Time-based signal quality reduction
- **Audio Integration**: Coordinated audio playback for realistic communication

#### **NavigationMaze (Lines 287-381)**
- **Role Separation**: Navigator (map view) vs Explorer (first-person view)
- **Location Progression**: 5-stage journey with increasing complexity
- **Failure Handling**: Thematic game-over messages with restart capability

#### **AlchemyLab (Lines 382-524)**
- **Multi-Step Processing**: Ingredient transformation through multiple stations
- **Drag-and-Drop Validation**: Server-side verification of ingredient movements
- **Recipe Validation**: Complex 4-step brewing process with combination mechanics
- **State Synchronization**: Real-time ingredient pool updates

#### **RuneProtocol (Lines 525-670)**
- **Logic Engine**: Advanced rule validation with conditional statements
- **Hint Toggling**: Optional validation feedback system
- **Level Progression**: Multiple difficulty levels with unique rule sets
- **Victory Detection**: Rule-satisfaction analysis rather than hardcoded solutions

#### **PictureExplanation (Lines 671-825)**
- **Voice Chat Integration**: Designed for external voice communication
- **Image Management**: Hide/show mechanics for strategic gameplay
- **Round Progression**: 5-round structure with increasing difficulty
- **Choice Validation**: Server-side image selection verification

#### **Word-Forge (Lines 826-934)**
- **Affix System**: Complex word formation with prefixes and suffixes
- **Game Modes**: Assisted vs Challenge difficulty levels
- **Combination Tracking**: Progress monitoring for word formation goals

### SignalR Event Patterns

Each puzzle broadcasts standardized event types:
- **`XXXGameJoined`**: Player successfully joins with role assignment
- **`XXXGameStateUpdated`**: Global game state changes
- **`XXXPlayerViewUpdated`**: Individual player-specific information updates
- **`XXXGameCompleted`**: Victory conditions met
- **`XXXGameFull`**: Room capacity reached
- **Invalid Action Events**: Puzzle-specific error handling

### Performance and Scalability Features

#### **Thread Safety**
- `ConcurrentDictionary` usage throughout for thread-safe operations
- Atomic game state updates to prevent race conditions

#### **Memory Management**
- Automatic cleanup of empty rooms in `OnDisconnectedAsync()` (Line 935)
- Player tracking removal on disconnection
- Game instance cleanup when no players remain

#### **Error Handling**
- Comprehensive try-catch blocks for game operations
- Graceful degradation when games not found
- Client-side validation with server-side verification

### 2025 Refactor: Act 1 Story Engine (Option A)

We extracted Act 1 story content and branching logic from `GameHub.cs` into a dedicated service.

- New files:
  - `Services/Act1StoryEngine.cs` (implements `IAct1StoryEngine`)
- DI registration:
  - `Program.cs`: `builder.Services.AddSingleton<IAct1StoryEngine, Act1StoryEngine>();`
- Hub changes:
  - Constructor injection of `IAct1StoryEngine`
  - Calls to create scenes now use `_act1StoryEngine.CreateEmergencyBriefingScene(squadName)`
  - Player views created via `_act1StoryEngine.CreatePlayerView(game, playerId)`
  - Scene progression via `_act1StoryEngine.ProgressToNextScene(game)`

Benefits:
- Hub becomes a thin coordinator; content and branching become testable and maintainable
- Server remains authoritative for multiplayer sync and anti-cheat

Extending to more Acts:
- Add new methods/classes in `Services/` (e.g., `Act2StoryEngine` or unify under a generic `VisualNovelEngine`)
- Keep hub methods thin; delegate to services and broadcast updated views

### Future Maintenance Guidelines

#### **Adding New Puzzles**
1. **Add Static Dictionary** (after Line 18): `private static readonly ConcurrentDictionary<string, NewPuzzleGame> _newPuzzleGames = new();`
2. **Insert Methods Section** (after Line 934): Follow established patterns for Join/Action/Restart methods
3. **Update Documentation**: Add line ranges and method descriptions to this section

#### **Modifying Existing Puzzles/Acts**
- **CodeCracker**: Lines 112-190 - Word bank and scoring modifications
- **SignalDecoder**: Lines 191-286 - Emergency scenario additions
- **NavigationMaze**: Lines 287-381 - Location progression changes
- **AlchemyLab**: Lines 382-524 - Recipe and ingredient system updates
- **RuneProtocol**: Lines 525-670 - Logic rule additions and level creation
- **PictureExplanation**: Lines 671-825 - Image set and round structure changes
- **Word-Forge**: Lines 826-934 - Affix system and difficulty adjustments
- **Act 1 Story**: Content/branching lives in `Services/Act1StoryEngine.cs`; hub delegates to this service

#### **Connection Management**
- Room cleanup logic: Lines 935-960
- Player tracking: Lines 20-53
- Group management: Standard SignalR patterns throughout

This centralized architecture allows for consistent multiplayer experiences across all puzzle types while maintaining clear separation of concerns for each game system.