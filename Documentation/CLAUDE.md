# Arcane Coop - Claude.md

This file provides guidance to Claude Code when working with the Arcane Coop escape room project.

## Project Overview

**Arcane Coop** is a sophisticated cooperative puzzle game platform built with ASP.NET Core Blazor Server (.NET 9.0). Set in the Arcane universe, it features 7 distinct puzzle systems where two players representing Zaun and Piltover must work together to solve challenges through real-time communication and collaboration.

## Development Commands

### Build Commands
```bash
dotnet build
dotnet clean
dotnet restore
```

### Running the Application
**Note: The user prefers to run the application manually.**
The application runs on:
- HTTP: http://localhost:5055
- HTTPS: https://localhost:7104

When the user runs `dotnet run`, the application will be available at the above URLs.

### Publishing
```bash
dotnet publish -c Release
```

## Architecture

### Project Structure
- **Program.cs**: Main entry point with minimal API setup
- **Components/**: Contains all Razor components
  - **App.razor**: Root component with HTML document structure
  - **Routes.razor**: Router configuration
  - **_Imports.razor**: Global using statements
  - **Layout/MainLayout.razor**: Base layout component
  - **Pages/**: Page components
    - **LandingPage.razor**: Main game selection page with extensive CSS styling
    - **Error.razor**: Standard error page

### Technology Stack
- **Framework**: ASP.NET Core 9.0 with Blazor Server
- **Rendering**: Interactive Server Components
- **Styling**: Component-scoped CSS with extensive custom styling
- **Fonts**: Custom "Arcane Nine" font and Google Fonts (Orbitron, Cinzel, Rajdhani)

### Service Layer (2025)
- **Act1StoryEngine**: Server-side story engine for Act 1. Provides scene content, player view construction, and progression logic
  - File: `Services/Act1StoryEngine.cs`
  - Interface: `IAct1StoryEngine`
  - Registered in `Program.cs` via DI: `AddSingleton<IAct1StoryEngine, Act1StoryEngine>()`

### Core Features
- **7 Cooperative Puzzle Systems** - Each with unique mechanics and educational focus
- **Real-time Multiplayer** - SignalR-powered synchronization between players
- **Dual-theme Arcane Design** - Zaun (teal/underground) vs Piltover (gold/clean) aesthetics
- **Role-based Gameplay** - Players have different views and responsibilities
- **Educational Focus** - Designed for ESL students and skill development

### Development Patterns
- Uses **minimal APIs** for simple setup
- **Component-scoped CSS** with extensive styling (1000+ lines in LandingPage)
- **Enum-based** city selection (City.Zaun, City.Piltover)
- **Async/await** patterns for component interactions
- **Cascading parameters** for context sharing
- **CSS @ symbols must be escaped** in Razor components: use `@@keyframes`, `@@media`, `@@import`, `@@font-face`
- **Server-authoritative story flow**: Hubs remain thin; story content and branching live in services (e.g., `Act1StoryEngine`)

### Visual Novel Multiplayer Editor Notes (2025)

For reliable Visual Novel behavior in multiplayer (Act 1) and in the visual editor:

- Use `CancellationTokenSource` and a `CancelTypewriter()` helper to cancel any in-flight typewriter animation
- Reset local text state (`displayedText`, `currentTextIndex`) and force a render before starting a new animation to avoid first-character carry-over
- On Skip, cancel the animation and set the full line once; also notify the server (see `Act1TypingCompleted`) so both clients' buttons flip from Skip ‚Üí Continue
- Add a `Act1TypingCompleted(roomId)` hub method that marks `IsTextAnimating=false` and `GameState.IsTextFullyDisplayed=true`, then broadcasts the updated `Act1PlayerView`
- After `Act1SceneTransition`, add a short client fallback (e.g., 4s) to navigate to the next game if the redirect message is missed

### Static Assets
- Located in **wwwroot/**
- Character images: Vi.jpeg, Cait.jpeg, Jayce.jpeg, Viktor.jpeg
- Custom font: Arcane Nine.otf
- Component-specific CSS files generated by build process

### Configuration
- Standard ASP.NET Core configuration in **appsettings.json**
- Development/Production environment support
- HTTPS redirection and HSTS enabled for production

## Legacy Systems

### Tic-Tac-Toe Demo (/test-signalr)
Early proof-of-concept for SignalR multiplayer functionality. Fully functional with real-time synchronization, but not part of the main escape room experience.



## SignalR Best Practices Summary

Key guidelines for robust multiplayer implementation:

- **Type Safety**: Always use strongly-typed data models for SignalR messages
- **State Sync**: Update both game state and player views after changes
- **Connection Management**: Handle joins, leaves, and disconnections gracefully
- **Server Validation**: Never trust client input - validate all actions server-side
- **Error Handling**: Comprehensive error messages and proper exception handling
- **Performance**: Use concurrent collections and batch updates when possible

See individual puzzle documentation for implementation examples.


## Puzzle Systems Overview

The project features 7 distinct cooperative puzzle systems, each designed for 2 players with asymmetric information and roles:

### 1. CodeCracker (/code-cracker)
**Purpose**: Vocabulary building and communication
**Players**: Piltover (sees distorted words) + Zaunite (gets clues)
**Mechanics**: Word decryption with hints and scoring
**Education**: ESL vocabulary, German translations
**Documentation**: [CodeCracker.md](./CodeCracker.md)

### 2. SignalDecoder (/signal-decoder) 
**Purpose**: Listening comprehension
**Players**: Piltover (sees incomplete text) + Zaunite (hears audio)
**Mechanics**: Audio-text coordination with emergency scenarios
**Education**: Listening skills, emergency vocabulary
**Documentation**: [SignalDecoder.md](./SignalDecoder.md)

**Story Integration Features:**
- **Story Mode Entry**: Accepts `story=true` parameter to bypass lobby setup
- **Role Preservation**: Uses `JoinSignalDecoderGameWithRole()` and `AddPlayerWithRole()` to maintain Piltover/Zaun assignments from visual novel
- **Complete Hub Integration**: New `JoinSignalDecoderGameWithRole()` hub method eliminates "Game is Full" errors during story transitions
- **Multiplayer Synchronization**: Fixed story-mode entry ensures both players transported to same testing room simultaneously

### 3. NavigationMaze (/navigation-maze)
**Purpose**: Spatial reasoning and direction following
**Players**: Piltover (map navigator) + Zaunite (first-person explorer)
**Mechanics**: Pathfinding through dangerous Zaun locations
**Education**: Prepositions, spatial vocabulary
**Documentation**: [NavigationMaze.md](./NavigationMaze.md)

### 4. PictureExplanation (/picture-explanation)
**Purpose**: Visual communication over voice chat
**Players**: Piltover (image describer) + Zaunite (choice selector)
**Mechanics**: Describe ‚Üí Hide ‚Üí Choose from 4 options
**Education**: Descriptive language, active listening
**Documentation**: [PictureExplanation.md](./PictureExplanation.md)

**Story Integration Features:**
- **Story Mode Entry**: Accepts `story=true` parameter to bypass lobby setup
- **Role Preservation**: Uses `JoinPictureExplanationGameWithRole()` to maintain Piltover/Zaun assignments from visual novel
- **Completion Transition**: "Continue Story" button (instead of "Play Again") when completing puzzle in story mode
- **Scene Targeting**: Redirects both players to next visual novel scene with `sceneIndex` parameter

### 5. RuneProtocol (/rune-protocol)
**Purpose**: Logic puzzles and conditional reasoning
**Players**: Piltover (R1-R4) + Zaunite (R5-R8)
**Mechanics**: Satisfy complex rule conditions through coordination
**Education**: Logic, Boolean algebra, systems thinking
**Documentation**: [RuneProtocol.md](./RuneProtocol.md)

### 6. AlchemyLab (/alchemy-lab)
**Purpose**: Process following and drag-and-drop interaction
**Players**: Piltover (recipe reader) + Zaunite (hands-on brewer)
**Mechanics**: Multi-step ingredient processing and combination
**Education**: Following instructions, sequential thinking
**Documentation**: [AlchemyLab.md](./AlchemyLab.md)

### 7. VisualNovel (/visual-novel)
**Purpose**: Narrative delivery and story immersion
**Players**: Single or dual player story experience
**Mechanics**: Text animation, character expressions, thematic presentation
**Education**: Reading comprehension, cultural context
**Documentation**: [VisualNovel.md](./VisualNovel.md)

## Technical Architecture

### Multiplayer Infrastructure
- **SignalR Hubs**: Real-time communication via `GameHub.cs` (thin coordinator)
- **Room-based Games**: Players join rooms using shared codes
- **Role Assignment**: First player = Piltover, Second = Zaunite
  - Story override: per-player URL `role` can request Piltover/Zaun; server resolves conflicts and ensures distinct roles
- **State Synchronization**: Server-side validation with client updates
- **Act 1 Story Engine**: `IAct1StoryEngine` owns scene content and branching
  - Hub methods (`JoinAct1Game`, `SkipAct1Text`, `ContinueAct1`, `Act1TypingCompleted`, `MakeAct1Choice`, `RestartAct1`) delegate to the engine and broadcast views
- **Connection Management**: Graceful handling of disconnections

### Data Models
- **Game-specific Models**: Each puzzle has dedicated model classes
- **Player Views**: Role-specific data structures for asymmetric gameplay
- **Game States**: Comprehensive state tracking for all game phases
  - Act 1 uses `Act1MultiplayerGame`, `Act1Player`, `Act1PlayerView`, `VisualNovelScene`, `DialogueLine`, `DialogueChoice`

### Component Architecture
- **Page Components**: Each puzzle is a standalone Blazor page
- **Shared Services**: Common functionality via dependency injection
- **CSS Theming**: Consistent Piltover/Zaun visual identity
- **Responsive Design**: Desktop-first with mobile support

## Story-Puzzle Transition System

The project implements a sophisticated transition system that allows seamless navigation between visual novel scenes and puzzle gameplay while preserving player roles, state, and multiplayer synchronization.

### Architecture Overview

**Flow Control Pattern:**
```
Visual Novel Scene ‚Üí Puzzle ‚Üí Next Visual Novel Scene
```

**Key Components:**
- **StoryProgression**: Ordered list defining the sequence (scenes and puzzle transitions)
- **Scene Index Management**: Tracks current position in the story progression
- **Role Preservation**: Maintains player roles (Piltover/Zaun) across transitions
- **Parameter Passing**: URL-based state transfer between different game types

### Story Progression Configuration

The story flow is controlled by the `StoryProgression` array in `Act1MultiplayerGame`:

```csharp
public List<string> StoryProgression { get; set; } = new() 
{ 
    "emergency_briefing",           // Scene 1 & 2 - Visual Novel
    "picture_explanation_transition", // Puzzle - Picture Explanation
    "database_revelation",          // Scene 3 - Visual Novel  
    "signal_decoder_transition",    // Puzzle - Signal Decoder
    "radio_decoded",                // Scene 4 - Visual Novel
    "renni_apartment",             // Scene 5 - Visual Novel
    "code_cracker_transition",     // Puzzle - Code Cracker
    "code_decoded",                // Scene 6 - Visual Novel (NEW)
    "navigation_maze_transition"   // Puzzle - Navigation Maze
};
```

**Key Updates (2025):**
- **Complete Signal Decoder Integration**: Full story-to-puzzle and puzzle-to-story transitions
- **Fixed Scene 3 Transitions**: Scene 3 (Database Revelation) now correctly transitions to Signal Decoder instead of Picture Explanation
- **Dynamic Progression Logic**: System automatically determines next puzzle based on current scene index

### From Scene to Puzzle Transitions

**Step 1: Scene Completion Detection**
- Visual novel reaches end of dialogue
- `_act1StoryEngine.ProgressToNextScene()` is called
- System detects `*_transition` phase in StoryProgression

**Step 2: Transition Initialization**
```csharp
case "picture_explanation_transition":
    game.Status = Act1GameStatus.SceneTransition;
    game.ShowTransition = true;
    game.NextGameName = "Visual Intelligence Analysis";
```

**Step 3: URL Construction with State Preservation**
```csharp
var parameters = $"role={p.PlayerRole}&avatar={p.PlayerAvatar}&name={Uri.EscapeDataString(p.PlayerName)}&squad={Uri.EscapeDataString(p.OriginalSquadName)}&story=true";
var url = $"/picture-explanation?{parameters}";
```

**Critical Parameters:**
- `role`: Preserves Piltover/Zaun assignment
- `avatar`: Maintains visual identity
- `name`: Player identification
- `squad`: Room/session identifier
- `story=true`: Enables story mode in puzzle

**Step 4: Synchronized Player Redirection**
```csharp
foreach (var p in game.Players)
{
    result.RedirectUrlsByPlayerId[p.PlayerId] = url;
}
```

### From Puzzle to Scene Transitions

**Step 1: Puzzle Completion**
- Puzzle game reaches completion state
- Story-mode conditional UI appears

**Step 2: Continue Story Button**
```razor
@if (isFromStory)
{
    <button class="arcane-btn arcane-btn-success" @onclick="ContinueStory">
        ‚û°Ô∏è Continue Story
    </button>
}
```

**Step 3: Hub Method for Story Continuation**
```csharp
public async Task ContinueStoryToScene3(string roomId)
{
    // Get puzzle players
    var connectedPlayers = game.GetConnectedPlayers();
    
    // Build Act1 URLs with scene targeting
    var parameters = $"role={roleName}&avatar=1&name={playerName}&roomId={roomId}&squad={roomId}&sceneIndex=2";
    var url = $"/act1-multiplayer?{parameters}";
}
```

**Critical Parameters for Scene Targeting:**
- `roomId`: Primary identifier for Act1 game room
- `squad`: Secondary identifier (same as roomId for continuity)  
- `sceneIndex`: Specifies which scene to start at (bypasses early scenes)

**Step 4: Scene Index Handling**
```csharp
public async Task JoinAct1GameAtScene(string roomId, string playerName, string originalSquadName, string role, string avatar, int? startAtSceneIndex)
{
    if (startAtSceneIndex.HasValue && startAtSceneIndex.Value >= 0)
    {
        game.CurrentSceneIndex = startAtSceneIndex.Value;
        var currentPhase = game.StoryProgression[game.CurrentSceneIndex];
        
        if (currentPhase == "database_revelation")
        {
            game.CurrentScene = _act1StoryEngine.CreateDatabaseRevelationScene(originalSquadName, game);
        }
    }
}
```

### Implementation Requirements

#### For Scene-to-Puzzle Transitions

**1. StoryEngine Updates (Services/Act1StoryEngine.cs)**
```csharp
case "puzzle_name_transition":
    game.Status = Act1GameStatus.SceneTransition;
    game.ShowTransition = true;
    game.NextGameName = "Puzzle Display Name";
    
    result.TransitionStarted = true;
    result.NextGameName = game.NextGameName;
    
    var puzzleUrls = new Dictionary<string, string>();
    foreach (var p in game.Players)
    {
        var parameters = $"role={p.PlayerRole}&avatar={p.PlayerAvatar}&name={Uri.EscapeDataString(p.PlayerName)}&squad={Uri.EscapeDataString(p.OriginalSquadName)}&story=true";
        puzzleUrls[p.PlayerId] = $"/puzzle-url?{parameters}";
    }
    result.RedirectUrlsByPlayerId = puzzleUrls;
```

**2. Visual Novel UI (Act1Multiplayer.razor)**
- Transition screen with loading animation
- Fallback redirect mechanism (4-second timer)
- `hasNavigatedToNextGame` flag to prevent duplicate redirects

#### For Puzzle-to-Scene Transitions

**1. Puzzle Completion UI**
```razor
@if (isFromStory && gameState.IsCompleted)
{
    <button class="arcane-btn arcane-btn-success" @onclick="ContinueStory">
        ‚û°Ô∏è Continue Story
    </button>
}
```

**2. SignalR Hub Method (GameHub.cs)**
```csharp
public async Task ContinuePuzzleToNextScene(string roomId, int targetSceneIndex)
{
    var puzzleGame = GetPuzzleGame(roomId);
    var players = puzzleGame.GetConnectedPlayers();
    
    foreach (var connectionId in players)
    {
        var playerData = GetPlayerData(connectionId);
        var url = $"/act1-multiplayer?role={playerData.Role}&roomId={roomId}&squad={roomId}&sceneIndex={targetSceneIndex}";
        await Clients.Client(connectionId).SendAsync("RedirectToNextScene", url);
    }
}
```

**3. Scene Index Support (Act1Multiplayer.razor)**
```csharp
// URL Parsing
if (int.TryParse(query["sceneIndex"], out int targetSceneIndex))
{
    startAtSceneIndex = targetSceneIndex;
}

// Hub Method Selection
if (startAtSceneIndex.HasValue)
{
    await hubConnection.SendAsync("JoinAct1GameAtScene", currentRoomId, playerName, originalSquadName, playerRole, playerAvatar, startAtSceneIndex.Value);
}
```

### Critical Implementation Details

#### Enhanced Fallback Mechanism (2025)
The system now features a **dynamic fallback URL generation** system that eliminates hardcoded transitions and handles scene index loss:

**Problem Solved:**
- **Scene Index Loss**: Transition state was causing scene index to be lost during fallback
- **Hardcoded URLs**: Fallback mechanism had hardcoded Picture Explanation URL regardless of actual story position
- **Incorrect Transitions**: Scene 3 was incorrectly transitioning to Picture Explanation instead of Signal Decoder

**Solution Implementation:**
```csharp
// Scene index storage during transition (Act1Multiplayer.razor)
private int transitionFromSceneIndex = 0;

// Store scene index when transition starts
private async Task HandleSceneTransition(string nextGameName)
{
    transitionFromSceneIndex = currentSceneIndex; // Capture before transition state
    hasNavigatedToNextGame = false;
    StateHasChanged();
}

// Dynamic URL generation based on story progression
private string GetFallbackTransitionUrl(string nameParam, string squadParam)
{
    var currentSceneIndex = transitionFromSceneIndex; // Use stored index
    var nextSceneIndex = currentSceneIndex + 1;
    var storyProgression = new[] { "emergency_briefing", "picture_explanation_transition", "database_revelation", "signal_decoder_transition" };
    
    var nextPhase = nextSceneIndex < storyProgression.Length ? storyProgression[nextSceneIndex] : "";
    
    return nextPhase switch
    {
        "picture_explanation_transition" => $"/picture-explanation?role={playerRole}&avatar={playerAvatar}&name={Uri.EscapeDataString(nameParam)}&squad={Uri.EscapeDataString(squadParam)}&story=true",
        "signal_decoder_transition" => $"/signal-decoder?role={playerRole}&avatar={playerAvatar}&name={Uri.EscapeDataString(nameParam)}&squad={Uri.EscapeDataString(squadParam)}&story=true",
        _ => $"/picture-explanation?role={playerRole}&avatar={playerAvatar}&name={Uri.EscapeDataString(nameParam)}&squad={Uri.EscapeDataString(squadParam)}&story=true" // Fallback
    };
}
```

**Enhanced Debug Logging:**
```csharp
Console.WriteLine($"[Act1Multiplayer] Fallback triggered - stored scene index: {transitionFromSceneIndex}");
Console.WriteLine($"[Act1Multiplayer] Next phase determined: {nextPhase}");
Console.WriteLine($"[Act1Multiplayer] Fallback URL: {fallbackUrl}");
```

#### Parameter Name Consistency
**‚ùå Common Error:**
```
Puzzle redirects to: /act1-multiplayer?squad=roomName&sceneIndex=2
Act1Multiplayer expects: roomId parameter
Result: Empty currentRoomId ‚Üí Squad Synchronization failure
```

**‚úÖ Correct Implementation:**
```
Puzzle redirects to: /act1-multiplayer?roomId=roomName&squad=roomName&sceneIndex=2
Act1Multiplayer parses: currentRoomId = roomName ‚úì
```

#### Role Preservation Strategy
- **Never rely on automatic assignment** (first=Piltover, second=Zaun) 
- **Always pass explicit `role` parameter** in transition URLs
- **Handle role conflicts** in puzzle join methods (second player gets remaining role)
- **Maintain role consistency** throughout entire session

#### State Synchronization Points
1. **Scene Completion**: Check if all players reached the end
2. **Transition Start**: Ensure both players get redirect simultaneously  
3. **Puzzle Join**: Wait for both players before starting puzzle
4. **Puzzle Completion**: Only show continue button when both players finished
5. **Scene Resume**: Both players must join Act1 game before story continues

#### Error Handling Requirements
- **Connection Failures**: Graceful degradation with fallback redirects
- **Parameter Errors**: Clear error messages for debugging
- **Room Mismatches**: Prevent players from joining wrong sessions
- **State Desync**: Automatic recovery mechanisms

### Testing and Debugging

#### Debug Logging Strategy
```csharp
Console.WriteLine($"[GameHub] Redirecting player {connectionId} to: {url}");
Console.WriteLine($"[Act1Multiplayer] Parsed URL params - RoomId: '{currentRoomId}', SceneIndex: {startAtSceneIndex}");
Console.WriteLine($"[Act1Multiplayer] Joining Act1 game at scene {startAtSceneIndex.Value}");
```

#### Common Issues and Solutions

**Issue: "Squad Synchronization" Loop** ‚úÖ FIXED (2025)
- **Cause**: Missing or incorrect `roomId` parameter
- **Solution**: Verify URL construction includes both `roomId` and `squad` parameters
- **Implementation**: Enhanced parameter validation and debug logging added

**Issue: Players Start at Wrong Scene** ‚úÖ FIXED (2025)
- **Cause**: Scene index not handled for second player
- **Solution**: Update join logic to handle `startAtSceneIndex` for all players
- **Implementation**: `JoinAct1GameAtScene` now handles scene index for all joining players

**Issue: Role Assignments Switch** ‚úÖ IMPROVED (2025)
- **Cause**: Relying on join order instead of explicit role parameter
- **Solution**: Always use `JoinPuzzleGameWithRole` methods with explicit role requests
- **Implementation**: Signal Decoder now uses `JoinSignalDecoderGameWithRole()` and `AddPlayerWithRole()`

**Issue: Players Get Stuck in Transition** ‚úÖ FIXED (2025)
- **Cause**: Redirect URLs not sent or navigation blocked, scene index loss during fallback
- **Solution**: Implement dynamic fallback redirect with scene index storage
- **Implementation**: Enhanced fallback mechanism with `transitionFromSceneIndex` storage and dynamic URL generation

**Issue: Scene 3 Wrong Transition** ‚úÖ FIXED (2025)
- **Cause**: Hardcoded fallback URL always redirected to Picture Explanation
- **Solution**: Dynamic fallback URL generation based on current story progression
- **Implementation**: `GetFallbackTransitionUrl()` method with story progression awareness

**Issue: Signal Decoder "Game is Full" Errors** ‚úÖ FIXED (2025)
- **Cause**: Missing hub methods for story mode integration
- **Solution**: Added `JoinSignalDecoderGameWithRole()` hub method and `AddPlayerWithRole()` game logic
- **Implementation**: Complete Signal Decoder story integration with role preservation

### Transition Parameter System (2025 Update)

The project implements a sophisticated transition parameter system that creates unique lobby names for each transition between scenes and puzzles. This prevents room name conflicts and eliminates "party is already full" errors during story-puzzle transitions.

#### Key Implementation Details

**URL Parameter Addition:**
- All scene-to-puzzle transitions now include a `transition` parameter
- Example: `&transition=FromScene1and2` or `&transition=FromScene3`

**Unique Room ID Generation:**
- Puzzle pages parse the transition parameter
- Create unique room IDs by combining squad name with transition source
- Format: `{squadName}_{transitionSource}`
- Example: `SquadAlpha_FromScene1and2`

**Squad Name Extraction:**
- When transitioning back from puzzles, extract original squad name from room ID
- Remove transition suffix using: `roomId.Contains("_") ? roomId.Substring(0, roomId.IndexOf("_")) : roomId`
- Create new unique room ID for next phase

**Transition Flow:**
```
Scene 1&2 ‚Üí Picture Explanation: SquadAlpha ‚Üí SquadAlpha_FromScene1and2
Picture Explanation ‚Üí Scene 3: SquadAlpha_FromScene1and2 ‚Üí SquadAlpha_FromPicturePuzzle
Scene 3 ‚Üí Signal Decoder: SquadAlpha_FromPicturePuzzle ‚Üí SquadAlpha_FromScene3
Signal Decoder ‚Üí Next Scene: SquadAlpha_FromScene3 ‚Üí SquadAlpha_FromSignalDecoder
```

**Synchronized Redirects:**
- Both players receive redirect messages simultaneously using `Task.WhenAll`
- Small client-side delay ensures coordinated navigation
- Prevents race conditions where one player creates room before other joins

**Why This Solves the Problem:**
Previously, both players would try to join the same room name that was already in use from a previous phase, causing "party is already full" errors. Now each transition creates a new, unique lobby while preserving the original squad name for display purposes.

**Critical Files Modified:**
- `Act1StoryEngine.cs`: Added transition parameters to puzzle redirect URLs
- `PictureExplanation.razor`: Parse transition parameter, create unique room IDs
- `SignalDecoder.razor`: Parse transition parameter, create unique room IDs  
- `GameHub.cs`: Extract original squad names, create unique room IDs for transitions
- `Act1Multiplayer.razor`: Updated fallback URLs with transition parameters

This comprehensive transition system enables seamless story-driven gameplay where puzzles feel integrated into the narrative rather than separate mini-games.

## Scene Selection Testing System (2025)

The project now includes a comprehensive testing system that allows developers to quickly test specific story scenes and puzzle transitions without playing through the entire campaign. This system is accessible through the Character Lobby once a squad is verified.

### Architecture Overview

**Access Pattern:**
```
Character Lobby ‚Üí Squad Verification ‚Üí "Continue Where You Left Off" ‚Üí Scene Selection Grid
```

**Key Components:**
- **Two-Step Testing Process**: Initial button reveals full scene selection interface
- **Synchronized Transport**: Both players transported to same testing room simultaneously via SignalR
- **Role Preservation**: Maintains Piltover/Zaun assignments throughout testing
- **Scene & Puzzle Options**: Start from visual novel scenes OR puzzle transitions

### Implementation Details

#### **Testing Section UI (CharacterLobby.razor)**
```csharp
// Development Testing Section (lines 202-264)
@if (squadVerified)
{
    <div class="testing-section">
        <div class="testing-card">
            @if (!showSceneSelection)
            {
                // Step 1: Initial testing option
                <button class="nav-btn test-option-btn" @onclick="ShowSceneSelection">
                    Continue Where You Left Off
                </button>
            }
            else
            {
                // Step 2: Full scene selection grid
                <div class="scene-selection-grid">
                    <div class="scene-group">
                        <h5>üìñ Visual Novel Scenes</h5>
                        <button @onclick="() => StartFromScene(0)">Emergency Briefing</button>
                        <button @onclick="() => StartFromScene(2)">Database Revelation</button>
                    </div>
                    <div class="scene-group">
                        <h5>üß© Puzzle Transitions</h5>
                        <button @onclick="StartFromPictureExplanation">Picture Explanation</button>
                        <button @onclick="StartFromSignalDecoder">Signal Decoder</button>
                    </div>
                </div>
            }
        </div>
    </div>
}
```

#### **Hub Methods for Testing (GameHub.cs)**
```csharp
// Redirect both players to specific Act1 scene
public async Task RedirectPlayersToAct1WithScene(string roomId, int sceneIndex)
{
    // Generate shared room name for testing
    var sharedTestLobbyName = GenerateSharedTestLobbyName(roomId, sceneIndex);
    
    // Transport both players to same Act1 testing room
    await Clients.Group(roomId).SendAsync("RedirectToAct1WithScene", 
        sharedTestLobbyName, sceneIndex);
}

// Redirect both players to specific puzzle
public async Task RedirectPlayersToPuzzle(string roomId, string puzzleName)
{
    var sharedTestLobbyName = GenerateSharedTestLobbyName(roomId, puzzleName);
    var puzzleUrl = GetPuzzleUrlForTesting(puzzleName, sharedTestLobbyName);
    
    await Clients.Group(roomId).SendAsync("RedirectToPuzzle", puzzleUrl);
}

// Ensure both players get same room name for synchronized testing
private string GenerateSharedTestLobbyName(string originalRoomId, object testIdentifier)
{
    return $"{originalRoomId}_test_{testIdentifier}_{DateTime.UtcNow:HHmmss}";
}
```

### Available Testing Options

#### **Visual Novel Scenes**
1. **Emergency Briefing (Scene 0)**: 
   - Start from story beginning
   - Includes both player choice points
   - Full character introductions and mission setup

2. **Database Revelation (Scene 2)**:
   - Start after Picture Explanation puzzle
   - Database discovery and Project Safeguard revelation
   - Radio setup sequence

#### **Puzzle Transitions**
1. **Picture Explanation**:
   - Story mode enabled (`story=true`)
   - Role preservation from character selection
   - "Continue Story" button leads to Scene 3

2. **Signal Decoder**:
   - Complete story integration with role preservation
   - Uses `JoinSignalDecoderGameWithRole()` hub method
   - Synchronized multiplayer entry

### Technical Implementation Features

#### **Shared Room Generation**
```csharp
private string GenerateSharedTestLobbyName(string originalRoomId, object identifier)
{
    // Creates unique room name that both players receive
    // Format: "originalRoom_test_sceneIndex_timestamp"
    // Example: "squad_alpha_test_2_143052"
    return $"{originalRoomId}_test_{identifier}_{DateTime.UtcNow:HHmmss}";
}
```

#### **Role Preservation Logic**
```csharp
private async Task StartFromScene(int sceneIndex)
{
    Console.WriteLine($"[CharacterLobby] Starting from scene {sceneIndex}");
    
    // Preserve role assignments from character selection
    await hubConnection.SendAsync("RedirectPlayersToAct1WithScene", currentRoomId, sceneIndex);
}

private async Task StartFromPictureExplanation()
{
    // Story mode puzzle with role preservation
    var puzzleUrl = $"/picture-explanation?story=true&role={selectedRole}";
    await hubConnection.SendAsync("RedirectPlayersToPuzzle", currentRoomId, "picture_explanation");
}
```

#### **Synchronized Player Transport**
Both players receive the same redirect simultaneously via SignalR:
```csharp
// Client-side redirect handling
hubConnection.On<string, int>("RedirectToAct1WithScene", (roomId, sceneIndex) =>
{
    var url = $"/act1-multiplayer?roomId={roomId}&squad={roomId}&sceneIndex={sceneIndex}&role={selectedRole}";
    navigationManager.NavigateTo(url);
});

hubConnection.On<string>("RedirectToPuzzle", (puzzleUrl) =>
{
    navigationManager.NavigateTo(puzzleUrl);
});
```

### Benefits for Development and Testing

#### **Rapid Testing Workflow**
1. **Quick Scene Access**: Jump directly to any story scene without playing through prerequisites
2. **Puzzle Testing**: Test puzzle integration with story mode enabled
3. **Multiplayer Sync**: Verify both players receive same experience
4. **Role Testing**: Ensure role preservation works across transitions

#### **Debug and QA Support**
1. **Isolated Testing**: Test specific scenes without dependencies
2. **Transition Validation**: Verify story-puzzle-story flow works correctly
3. **Performance Testing**: Measure loading times for different entry points
4. **Content Review**: Review dialogue and scenes without full playthrough

#### **Developer Experience**
```
Traditional Flow: Character Select ‚Üí Story Start ‚Üí Scene 1 ‚Üí Scene 2 ‚Üí Puzzle 1 ‚Üí Scene 3
Testing Flow:     Character Select ‚Üí Scene Selection ‚Üí Direct Scene 3 Access (saves ~10+ minutes)
```

### Usage Guidelines

#### **For Developers**
1. **Use for Content Review**: Quickly access any story scene to review dialogue or visuals
2. **Debug Transitions**: Test specific transition points that may be problematic
3. **Performance Testing**: Measure scene loading and transition times
4. **Integration Testing**: Verify story-puzzle-story flow integrity

#### **For QA Testing**
1. **Scene Validation**: Verify each scene renders correctly and handles player choices
2. **Role Consistency**: Ensure player roles are preserved throughout testing
3. **Multiplayer Sync**: Confirm both players experience synchronized content
4. **Transition Testing**: Validate all story-to-puzzle and puzzle-to-story transitions

#### **Testing Best Practices**
1. **Always test with two players**: Testing system preserves multiplayer mechanics
2. **Verify role assignments**: Check that Piltover/Zaun roles remain consistent
3. **Test full transitions**: Use "Continue Story" buttons to verify end-to-end flow
4. **Use shared rooms**: Ensure both players join same testing room for synchronized experience

This testing system dramatically improves development velocity by providing instant access to any story content while maintaining the full multiplayer experience and role preservation mechanics.

## Development Guidelines

### Adding New Puzzles
1. Create page component in Components/Pages/
2. Add models in Models/ directory
3. Implement SignalR methods in GameHub.cs
4. Create comprehensive documentation in Documentation/
5. Update this CLAUDE.md with basic overview

### Code Standards
- **SignalR Type Safety**: Always use strongly-typed data models
- **Error Handling**: Graceful degradation for network issues
- **State Management**: Separate client/server state concerns
- **Animation**: Hardware-accelerated CSS for 60fps performance
- **Accessibility**: ARIA labels and keyboard navigation

### Educational Focus
- **German ESL Students**: Primary target audience
- **Collaborative Learning**: Peer-to-peer skill development
- **Progressive Difficulty**: Scaffolded complexity increases
- **Multiple Modalities**: Visual, auditory, kinesthetic learning styles

## File Organization

### Core Files
- **Program.cs**: Application entry point and service configuration
- **GameHub.cs**: SignalR hub with all multiplayer functionality
- **appsettings.json**: Configuration for development and production

### Component Structure
- **Pages/**: All puzzle components and main game pages
- **Models/**: Data models for each puzzle system
- **Services/**: Shared services (VisualNovelService, etc.)
- `Act1StoryEngine` provides Act 1 narrative; `VisualNovelService` provides generic VN scenes/utilities
- **wwwroot/**: Static assets (images, audio, fonts, styles)

### Documentation Structure
- **CLAUDE.md**: This overview and development guidance
- **[PuzzleName].md**: Detailed documentation for each puzzle system
- **Specialized docs**: Technical deep-dives for complex systems

## GameHub.cs - Central SignalR Hub Documentation

The `GameHub.cs` file serves as the central multiplayer coordination hub for all puzzle systems in the Arcane Coop project. This SignalR hub manages real-time communication, game state synchronization, and player coordination across all puzzle types.

### File Structure Overview

**Core Infrastructure (Lines 1-64)**
- Static game dictionaries for each puzzle type
- Room and player management
- Basic SignalR connection handling

**Game-Specific Sections (high level):**
- **Tic-Tac-Toe** (Lines 65-111): Legacy demo system with basic turn-based gameplay
- **CodeCracker** (Lines 112-190): Vocabulary puzzle with word guessing and hint system
- **SignalDecoder** (Lines 191-286): Audio-based emergency transmission decoding
- **NavigationMaze** (Lines 287-381): Spatial navigation with route planning
- **AlchemyLab** (Lines 382-524): Drag-and-drop ingredient processing and brewing
- **RuneProtocol** (Lines 525-670): Complex logic puzzle with conditional rule systems
- **PictureExplanation** (Lines 671-825): Voice chat visual communication challenges
- **Word-Forge** (Lines 826-934): Advanced word formation and affix combinations
 - **Act 1 Story (thin)**: Delegates to `IAct1StoryEngine` for content and branching; hub focuses on joins, skips, continue, typing completion, choices, restarts, and broadcasting

**Connection Management (Lines 935-end)**: Player disconnection handling and cleanup

### Static Game Storage Architecture

```csharp
// Each puzzle type maintains its own concurrent dictionary (Lines 10-18)
private static readonly ConcurrentDictionary<string, TicTacToeGame> _games = new();
private static readonly ConcurrentDictionary<string, CodeCrackerGame> _codeCrackerGames = new();
private static readonly ConcurrentDictionary<string, SimpleSignalDecoderGame> _signalDecoderGames = new();
private static readonly ConcurrentDictionary<string, NavigationMazeGame> _navigationMazeGames = new();
private static readonly ConcurrentDictionary<string, AlchemyGame> _alchemyGames = new();
private static readonly ConcurrentDictionary<string, RuneProtocolGame> _runeProtocolGames = new();
private static readonly ConcurrentDictionary<string, PictureExplanationGame> _pictureExplanationGames = new();
private static readonly ConcurrentDictionary<string, WordForgeGame> _wordForgeGames = new();
private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, string>> _roomPlayers = new();
```

### Common Method Patterns

Each puzzle section follows consistent patterns:

#### 1. **Join Game Methods** (Lines 113, 192, 288, 383, 526, 672, 827)
- Pattern: `JoinXXXGame(string roomId, string playerName)`
- Adds player to SignalR group
- Creates or retrieves game instance
- Assigns player role (typically Piltover vs Zaunite)
- Sends initial game state and player-specific view

#### 2. **Game Action Methods** (Varies by puzzle)
- **CodeCracker**: `SubmitCodeCrackerGuess()` (Line 132), `RequestCodeCrackerHint()` (Line 163)
- **SignalDecoder**: `SubmitSignalDecoding()` (Line 232)
- **NavigationMaze**: `MakeNavigationChoice()` (Line 315)
- **AlchemyLab**: `ProcessIngredient()` (Line 409), `AddToCauldron()` (Line 440), `SubmitPotion()` (Line 473)
- **RuneProtocol**: `ToggleRune()` (Line 557), `ToggleRuneProtocolValidationHints()` (Line 602)
- **PictureExplanation**: `SubmitPictureChoice()` (Line 736), `NextPictureRound()` (Line 780)
- **Word-Forge**: `ForgeWordCombination()` (Line 890)

#### 3. **Restart/Reset Methods** (Lines 176, 243, 353, 510, 637, 810, 919)
- Pattern: `RestartXXXGame(string roomId)`
- Resets game state to initial conditions
- Broadcasts updated state to all players

### Advanced Features by Puzzle

#### **CodeCracker (Lines 112-190)**
- **Hint System**: Players can request hints with usage tracking
- **Scoring System**: Points based on speed and accuracy
- **Progressive Difficulty**: Word complexity increases through rounds
- **Animation Coordination**: 2.5-second delays for success animations

#### **SignalDecoder (Lines 191-286)**
- **Emergency Scenarios**: Multiple crisis types (medical, fire, police, disasters)
- **Signal Degradation**: Time-based signal quality reduction
- **Audio Integration**: Coordinated audio playback for realistic communication

#### **NavigationMaze (Lines 287-381)**
- **Role Separation**: Navigator (map view) vs Explorer (first-person view)
- **Location Progression**: 5-stage journey with increasing complexity
- **Failure Handling**: Thematic game-over messages with restart capability

#### **AlchemyLab (Lines 382-524)**
- **Multi-Step Processing**: Ingredient transformation through multiple stations
- **Drag-and-Drop Validation**: Server-side verification of ingredient movements
- **Recipe Validation**: Complex 4-step brewing process with combination mechanics
- **State Synchronization**: Real-time ingredient pool updates

#### **RuneProtocol (Lines 525-670)**
- **Logic Engine**: Advanced rule validation with conditional statements
- **Hint Toggling**: Optional validation feedback system
- **Level Progression**: Multiple difficulty levels with unique rule sets
- **Victory Detection**: Rule-satisfaction analysis rather than hardcoded solutions

#### **PictureExplanation (Lines 671-825)**
- **Voice Chat Integration**: Designed for external voice communication
- **Image Management**: Hide/show mechanics for strategic gameplay
- **Round Progression**: 5-round structure with increasing difficulty
- **Choice Validation**: Server-side image selection verification

#### **Word-Forge (Lines 826-934)**
- **Affix System**: Complex word formation with prefixes and suffixes
- **Game Modes**: Assisted vs Challenge difficulty levels
- **Combination Tracking**: Progress monitoring for word formation goals

### SignalR Event Patterns

Each puzzle broadcasts standardized event types:
- **`XXXGameJoined`**: Player successfully joins with role assignment
- **`XXXGameStateUpdated`**: Global game state changes
- **`XXXPlayerViewUpdated`**: Individual player-specific information updates
- **`XXXGameCompleted`**: Victory conditions met
- **`XXXGameFull`**: Room capacity reached
- **Invalid Action Events**: Puzzle-specific error handling

### Performance and Scalability Features

#### **Thread Safety**
- `ConcurrentDictionary` usage throughout for thread-safe operations
- Atomic game state updates to prevent race conditions

#### **Memory Management**
- Automatic cleanup of empty rooms in `OnDisconnectedAsync()` (Line 935)
- Player tracking removal on disconnection
- Game instance cleanup when no players remain

#### **Error Handling**
- Comprehensive try-catch blocks for game operations
- Graceful degradation when games not found
- Client-side validation with server-side verification

### 2025 Refactor: Act 1 Story Engine (Option A)

We extracted Act 1 story content and branching logic from `GameHub.cs` into a dedicated service.

- New files:
  - `Services/Act1StoryEngine.cs` (implements `IAct1StoryEngine`)
- DI registration:
  - `Program.cs`: `builder.Services.AddSingleton<IAct1StoryEngine, Act1StoryEngine>();`
- Hub changes:
  - Constructor injection of `IAct1StoryEngine`
  - Calls to create scenes now use `_act1StoryEngine.CreateEmergencyBriefingScene(squadName)`
  - Player views created via `_act1StoryEngine.CreatePlayerView(game, playerId)`
  - Scene progression via `_act1StoryEngine.ProgressToNextScene(game)`

Benefits:
- Hub becomes a thin coordinator; content and branching become testable and maintainable
- Server remains authoritative for multiplayer sync and anti-cheat

Extending to more Acts:
- Add new methods/classes in `Services/` (e.g., `Act2StoryEngine` or unify under a generic `VisualNovelEngine`)
- Keep hub methods thin; delegate to services and broadcast updated views

### Future Maintenance Guidelines

#### **Adding New Puzzles**
1. **Add Static Dictionary** (after Line 18): `private static readonly ConcurrentDictionary<string, NewPuzzleGame> _newPuzzleGames = new();`
2. **Insert Methods Section** (after Line 934): Follow established patterns for Join/Action/Restart methods
3. **Update Documentation**: Add line ranges and method descriptions to this section

#### **Modifying Existing Puzzles/Acts**
- **CodeCracker**: Lines 112-190 - Word bank and scoring modifications
- **SignalDecoder**: Lines 191-286 - Emergency scenario additions
- **NavigationMaze**: Lines 287-381 - Location progression changes
- **AlchemyLab**: Lines 382-524 - Recipe and ingredient system updates
- **RuneProtocol**: Lines 525-670 - Logic rule additions and level creation
- **PictureExplanation**: Lines 671-825 - Image set and round structure changes
- **Word-Forge**: Lines 826-934 - Affix system and difficulty adjustments
- **Act 1 Story**: Content/branching lives in `Services/Act1StoryEngine.cs`; hub delegates to this service

#### **Connection Management**
- Room cleanup logic: Lines 935-960
- Player tracking: Lines 20-53
- Group management: Standard SignalR patterns throughout

This centralized architecture allows for consistent multiplayer experiences across all puzzle types while maintaining clear separation of concerns for each game system.