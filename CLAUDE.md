# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an **ASP.NET Core Blazor Server** application for an Arcane-themed cooperative escape room experience. The application uses .NET 9.0 and implements a dual-city theme with Zaun vs Piltover.

## Development Commands

### Running the Application
```bash
dotnet run
```
The application runs on:
- HTTP: http://localhost:5055
- HTTPS: https://localhost:7104

### Build Commands
```bash
dotnet build
dotnet clean
dotnet restore
```

### Publishing
```bash
dotnet publish -c Release
```

## Architecture

### Project Structure
- **Program.cs**: Main entry point with minimal API setup
- **Components/**: Contains all Razor components
  - **App.razor**: Root component with HTML document structure
  - **Routes.razor**: Router configuration
  - **_Imports.razor**: Global using statements
  - **Layout/MainLayout.razor**: Base layout component
  - **Pages/**: Page components
    - **LandingPage.razor**: Main game selection page with extensive CSS styling
    - **Error.razor**: Standard error page

### Technology Stack
- **Framework**: ASP.NET Core 9.0 with Blazor Server
- **Rendering**: Interactive Server Components
- **Styling**: Component-scoped CSS with extensive custom styling
- **Fonts**: Custom "Arcane Nine" font and Google Fonts (Orbitron, Cinzel, Rajdhani)

### Key Features
- **Dual-theme design** with Zaun (underground/cyberpunk) and Piltover (steampunk/golden) aesthetics
- **Character selection system** with Vi, Caitlyn, Jayce, and Viktor
- **Responsive design** with mobile-first approach
- **Interactive UI elements** with hover effects and animations
- **Audio controls** system (placeholder implementation)

### Development Patterns
- Uses **minimal APIs** for simple setup
- **Component-scoped CSS** with extensive styling (1000+ lines in LandingPage)
- **Enum-based** city selection (City.Zaun, City.Piltover)
- **Async/await** patterns for component interactions
- **Cascading parameters** for context sharing

### Static Assets
- Located in **wwwroot/**
- Character images: Vi.jpeg, Cait.jpeg, Jayce.jpeg, Viktor.jpeg
- Custom font: Arcane Nine.otf
- Component-specific CSS files generated by build process

### Configuration
- Standard ASP.NET Core configuration in **appsettings.json**
- Development/Production environment support
- HTTPS redirection and HSTS enabled for production

## Multiplayer Tic-Tac-Toe Implementation

### Implementation Workflow

#### 1. Analysis Phase
- Examined existing SignalR infrastructure in `TestSignalR.razor` and `GameHub.cs`
- Identified basic room management and messaging functionality
- Reviewed existing UI components and styling patterns

#### 2. Backend Implementation (`Hubs/GameHub.cs`)
- **Added TicTacToeGame class** with complete game logic:
  - Board state management (string[9] array)
  - Player management (X/O assignments)
  - Turn-based gameplay enforcement
  - Win condition detection (rows, columns, diagonals)
  - Tie game detection
- **Enhanced GameHub with game-specific methods**:
  - `JoinGame()` - Player joins tic-tac-toe game
  - `MakeMove()` - Process and validate player moves
  - `RestartGame()` - Reset game state
- **Added concurrent game management** using `ConcurrentDictionary<string, TicTacToeGame>`
- **Implemented disconnection handling** to clean up games when players leave

#### 3. Frontend Implementation (`Components/Pages/TestSignalR.razor`)
- **Enhanced UI with game interface**:
  - 3x3 grid using CSS Grid layout
  - Real-time game state display
  - Turn indicator and player symbol display
  - Game status messages
- **Added SignalR event handlers**:
  - `GameJoined` - Player successfully joins game
  - `GameStateUpdated` - Real-time board updates
  - `GameEnded` - Win/tie notifications with winning line highlighting
  - `InvalidMove` - Move validation feedback
- **Implemented game logic methods**:
  - Move validation and execution
  - Visual feedback for winning combinations
  - Game restart functionality
- **Added responsive CSS styling** with hover effects and visual indicators

#### 4. Testing and Validation
- Verified build process and resolved file locking issues
- Confirmed SignalR connectivity and real-time synchronization
- Validated multiplayer functionality across multiple browser instances

### Key Features Implemented

#### Game Mechanics
- **Turn-based gameplay** with server-side validation
- **Real-time synchronization** between players
- **Win detection** for all possible combinations (8 winning patterns)
- **Tie game handling** when board is full
- **Move validation** prevents invalid plays
- **Game restart** functionality for continuous play

#### User Interface
- **Clean 3x3 grid** with consistent cell sizing (100x100px)
- **Visual feedback** with hover effects and winning line highlighting
- **Game status display** showing current turn and game state
- **Player identification** with clear X/O symbol display
- **Integrated chat** for player communication
- **Responsive design** using Bootstrap classes

#### Multiplayer Architecture
- **Room-based games** supporting up to 2 players per room
- **Player disconnection handling** with automatic game cleanup
- **Connection state management** with visual status indicators
- **Error handling** for invalid moves and game full scenarios

### Technical Implementation Details

#### SignalR Hub Methods
```csharp
JoinGame(string roomId, string playerName)    // Join tic-tac-toe game
MakeMove(string roomId, int position)         // Make a move
RestartGame(string roomId)                    // Reset game state
```

#### Client-Side Event Handlers
```csharp
GameJoined          // Player joins game successfully
GameStateUpdated    // Real-time board state updates
GameEnded           // Game completion with winner/tie
InvalidMove         // Move validation errors
```

#### Game State Management
- **Server-side game state** stored in concurrent dictionary
- **Client-side state sync** through SignalR events  
- **Position-based board** (0-8 array indices)
- **Symbol assignment** (first player X, second player O)

### Usage Instructions
1. Navigate to `/test-signalr` page
2. Enter Room ID and Player Name
3. Click "Join Room" then "Join Game"
4. Play by clicking empty cells when it's your turn
5. Use "Restart Game" to play again
6. Chat functionality available for communication

## Code Cracker: Lexical Puzzle Implementation

### Game Overview
**Code Cracker** is a collaborative vocabulary-building game designed for German ESL students. Players work together to decode corrupted English words using various clues and hints.

#### Narrative Theme
- **Piltover Player (Caitlyn)**: Sees distorted words from Piltover's corrupted archives
- **Zaunite Player (Vi)**: Receives intelligence clues to help decode the words
- **Collaborative Gameplay**: Both players must communicate to solve word puzzles

### Implementation Details

#### Backend Architecture (`Hubs/GameHub.cs`)
- **CodeCrackerGame class** with comprehensive vocabulary puzzle system:
  - Word bank with 10 educational vocabulary words
  - Player role assignments (Piltover/Zaunite with different information views)
  - Progressive scoring system (10 points minus hints and attempts)
  - Three-tier hint system (word length, first letter, category)
  - Attempt tracking and game state management
- **Enhanced GameHub methods**:
  - `JoinCodeCrackerGame()` - Role-based player assignment
  - `SubmitCodeCrackerGuess()` - Word validation and progression
  - `RequestCodeCrackerHint()` - Progressive hint system
  - `RestartCodeCrackerGame()` - Game reset functionality
- **Concurrent game management** using dedicated dictionary for Code Cracker games
- **Role-based information filtering** ensuring each player sees appropriate clues

#### Frontend Implementation (`Components/Pages/CodeCracker.razor`)
- **Themed UI with Arcane styling**:
  - Piltover section: Golden gradient with distorted word display
  - Zaunite section: Dark gradient with intelligence clues
  - Responsive design with role-specific visual indicators
- **Real-time multiplayer features**:
  - SignalR event handlers for game state synchronization
  - Live attempt history display
  - Progressive hint system with usage tracking
  - Team communication chat system
- **Educational focus elements**:
  - German translation integration for ESL learning
  - Definition and synonym clues for vocabulary building
  - Scoring system encouraging efficient problem-solving

#### Key Features Implemented

#### Game Mechanics
- **Role-based gameplay** with distinct information views for each player
- **10-word vocabulary progression** with increasing complexity
- **Collaborative problem-solving** requiring communication between players
- **Progressive hint system** (3 hints per word: length, first letter, category)
- **Scoring system** rewarding efficiency (fewer hints and attempts = higher score)
- **Real-time synchronization** of all game state changes

#### Educational Value
- **German-English translation** support for ESL students
- **Multiple clue types** (definitions, synonyms, translations) for comprehensive learning
- **Vocabulary range** covering common English words with educational value
- **Collaborative learning** encouraging peer-to-peer assistance

#### User Interface
- **Immersive Arcane theming** with Piltover (golden) and Zaunite (dark) visual styles
- **Clear role differentiation** with distinct UI sections for each player type
- **Progress tracking** showing current word, score, and hints used
- **Attempt history** for tracking problem-solving approaches
- **Integrated team chat** for strategy coordination

#### Multiplayer Architecture
- **Room-based games** supporting exactly 2 players with distinct roles
- **Player disconnection handling** with automatic game cleanup
- **Real-time state synchronization** across all connected clients
- **Role-specific data filtering** ensuring appropriate information distribution

### Technical Implementation Details

#### SignalR Hub Methods
```csharp
JoinCodeCrackerGame(string roomId, string playerName)    // Join with role assignment
SubmitCodeCrackerGuess(string roomId, string guess)      // Submit word guess
RequestCodeCrackerHint(string roomId)                    // Request progressive hints
RestartCodeCrackerGame(string roomId)                    // Reset game state
```

#### Client-Side Event Handlers
```csharp
CodeCrackerGameJoined          // Player joins with role assignment
CodeCrackerGameStateUpdated    // Real-time game state synchronization
CodeCrackerGameCompleted       // Game completion with final score
CodeCrackerInvalidGuess        // Guess validation feedback
CodeCrackerHintReceived        // Progressive hint delivery
CodeCrackerPlayerViewUpdated   // Role-specific view updates
```

#### Game State Management
- **Server-side vocabulary bank** with educational word selection
- **Role-based information filtering** (Piltover sees distorted words, Zaunite sees clues)
- **Progressive scoring system** encouraging strategic hint usage
- **Attempt tracking** for learning assessment and replay value

### Usage Instructions (Code Cracker)
1. Navigate to `/code-cracker` page
2. Enter Room ID and Player Name
3. Click "Join Room" then "Join Game"
4. **Piltover Player**: Study the distorted word pattern
5. **Zaunite Player**: Analyze the definition, German translation, and synonym
6. **Both Players**: Collaborate via chat to solve the word
7. Submit guesses and use hints strategically
8. Progress through all 10 vocabulary words
9. Use "Restart Game" to play again with different word order

## SignalR Multiplayer Best Practices

### Key Insights for Robust SignalR Implementation

#### 1. **Type Safety is Critical**
- **Problem**: Using `dynamic` or `object` types in SignalR event handlers causes serialization issues and Blazor circuit crashes
- **Solution**: Create strongly-typed classes for data transfer between client and server
```csharp
// Backend - Strongly typed data classes
public class PlayerViewData { /* properties */ }
public class GameStateData { /* properties */ }

// Frontend - Matching client classes  
public class PlayerView { /* properties */ }
public class GameState { /* properties */ }

// SignalR event handlers with proper types
hubConnection.On<string, PlayerViewData>("GameJoined", (role, view) => { ... });
```

#### 2. **State Synchronization Patterns**
- **Always update both game state AND player views** after state changes
- **Use individual client updates** for role-specific data, group updates for shared state
```csharp
// Update shared game state
await Clients.Group(roomId).SendAsync("GameStateUpdated", game.GetGameState());

// Update individual player views with role-specific data
foreach (var player in game.GetConnectedPlayers())
{
    await Clients.Client(player).SendAsync("PlayerViewUpdated", game.GetPlayerView(player));
}
```

#### 3. **Connection Management**
- **Ensure players join SignalR groups** before game-specific operations
- **Handle duplicate join attempts** gracefully - return existing state instead of failing
- **Clean up games on disconnection** to prevent memory leaks
```csharp
public async Task JoinGame(string roomId, string playerName)
{
    // Always ensure group membership first
    await Groups.AddToGroupAsync(Context.ConnectionId, roomId);
    
    // Handle existing players gracefully
    var existingRole = game.GetExistingPlayerRole(Context.ConnectionId);
    if (existingRole != null) return existingRole;
}
```

#### 4. **Error Handling and Debugging**
- **Enable DetailedErrors in development** for better error visibility
- **Add comprehensive error messages** for invalid operations
- **Use proper exception handling** in hub methods
```json
// appsettings.Development.json
{
  "DetailedErrors": true
}
```

#### 5. **Game State Validation**
- **Validate all player actions** server-side (never trust client input)
- **Check game completion state** before processing actions
- **Implement proper turn management** for turn-based games
```csharp
public (bool Success, string Message) ProcessAction(string connectionId, object action)
{
    if (IsCompleted) return (false, "Game is already completed");
    if (!Players.ContainsKey(connectionId)) return (false, "Player not in game");
    if (!IsPlayerTurn(connectionId)) return (false, "Not your turn");
    // ... process action
}
```

#### 6. **Performance Considerations**
- **Use concurrent collections** for thread-safe game storage
- **Limit the size of data sent** in SignalR messages
- **Batch related updates** instead of sending multiple small updates
- **Clean up completed/abandoned games** periodically

#### 7. **Client-Side Resilience**
- **Handle connection drops gracefully** with automatic reconnection
- **Show connection status** to users
- **Disable actions during disconnection** to prevent errors
- **Use proper async/await patterns** in event handlers

#### Common Pitfalls to Avoid
- ❌ Using `dynamic` types in SignalR messages (causes crashes)
- ❌ Forgetting to update player views after game state changes
- ❌ Not validating player actions server-side
- ❌ Missing SignalR group membership before game operations
- ❌ Not handling duplicate join attempts
- ❌ Mixing async/sync code improperly in event handlers

## Important Notes

- This is a **game/entertainment application** focused on the Arcane universe
- The project emphasizes **visual design** with extensive CSS animations and effects
- **Character selection logic is not yet implemented** (see TODO comments in LandingPage.razor:1069)
- **Audio system is placeholder** functionality
- Uses **Blazor Server** rendering mode throughout
- **Multiplayer tic-tac-toe** now fully implemented with real-time synchronization